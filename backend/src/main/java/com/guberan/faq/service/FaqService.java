package com.guberan.faq.service;

import com.guberan.faq.dto.FaqDto;
import com.guberan.faq.mapper.FaqMapper;
import com.guberan.faq.model.ContextItem;
import com.guberan.faq.model.Faq;
import com.guberan.faq.repository.FaqRepository;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.vectorstore.QuestionAnswerAdvisor;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.document.Document;
import org.springframework.ai.vectorstore.SearchRequest;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.UUID;


/**
 * Service class for handling FAQ operations including AI-powered question answering,
 * validation of responses, and vector store management.
 */
@Service
@Slf4j
public class FaqService {
    public static final int TOP_K = 8;
    // Minimum similarity score to accept results; allows broad matches while filtering out irrelevant content
    public static final double SIMILARITY_THRESHOLD = 0.4;


    private final VectorStore vectorStore;
    private final ChatClient chatClient;
    private final FaqRepository faqRepository;
    private final FaqMapper faqMapper;
    private final QuestionAnswerAdvisor questionAnswerAdvisor;

    public FaqService(VectorStore vectorStore, ChatClient chatClient, FaqRepository faqRepository, FaqMapper faqMapper) {
        this.vectorStore = vectorStore;
        this.chatClient = chatClient;
        this.faqRepository = faqRepository;
        this.faqMapper = faqMapper;
        this.questionAnswerAdvisor = new QuestionAnswerAdvisor(this.vectorStore);
    }

    public List<FaqDto> getValidated(Boolean validated) {
        if (validated == null) {
            return faqRepository.findAll().stream().map(faqMapper::toDto).toList();
        }
        return faqRepository.findByValidated(validated).stream().map(faqMapper::toDto).toList();
    }

    /**
     * Ask a question to the AI system and generate an answer using RAG.
     *
     * @param userQuestionStr The user's question
     * @return FAQ DTO containing the question, AI-generated answer, and context
     * @throws ResponseStatusException if the question is empty or processing fails
     */
    public FaqDto ask(String userQuestionStr) {
        if (userQuestionStr == null || userQuestionStr.trim().isEmpty()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Question cannot be empty");
        }
        
        try {
            // Retrieve relevant documents
            List<Document> retrievedDocs = findSimilarValidatedFaq(userQuestionStr);
            List<ContextItem> contextItems = retrievedDocs.stream().map(faqMapper::toContextItem).toList();

            ChatResponse response = chatClient
                    .prompt()
                    .advisors(questionAnswerAdvisor)
                    .user(userQuestionStr)
                    .call()
                    .chatResponse();

            Faq faq = new Faq(userQuestionStr, response.getResult().getOutput().getText(), contextItems);
            faqRepository.save(faq);

            return faqMapper.toDto(faq);
        } catch (Exception e) {
            log.error("Error processing question: {}", userQuestionStr, e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error processing your question");
        }
    }

    /**
     * Validate and optionally correct an AI-generated answer.
     * Adds the validated FAQ to the vector store for future RAG retrieval.
     *
     * @param dto FAQ DTO with ID and corrected answer
     * @return Updated FAQ DTO
     * @throws ResponseStatusException if ID or answer is missing, or FAQ not found
     */
    public FaqDto validateResponse(FaqDto dto) {
        if (dto.getId() == null || dto.getAnswer() == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "ID and answer are required");
        }
        
        Faq faq = faqRepository.findById(UUID.fromString(dto.getId()))
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "FAQ not found"));
        faq.setAutoGenerated(!StringUtils.equals(faq.getAnswer(), dto.getAnswer()));
        faq.setAnswer(dto.getAnswer());
        faq.setValidated(true);
        faqRepository.save(faq);
        vectorStore.add(List.of(faqMapper.toDocument(faq)));
        log.info("âœ… FAQ response added to RAG {}", faq.getId());
        return faqMapper.toDto(faq);
    }


    /**
     * Delete a FAQ by ID from both the database and vector store.
     *
     * @param faqId UUID of the FAQ to delete
     * @return true if deleted successfully, false if FAQ not found
     */
    public boolean deleteFaq(UUID faqId) {
        if (faqRepository.existsById(faqId)) {
            faqRepository.deleteById(faqId);
            vectorStore.delete(List.of(faqId.toString()));
            return true;
        } else {
            return false;
        }
    }

    public List<Document> findSimilarValidatedFaq(String userQuestionStr) {
        SearchRequest searchRequest = SearchRequest.builder()
                .query(userQuestionStr)
                .topK(TOP_K)
                .similarityThreshold(SIMILARITY_THRESHOLD)
                .build();
        return vectorStore.similaritySearch(searchRequest);
    }
}
